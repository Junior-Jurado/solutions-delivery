# =============================================================================
# PIPELINE: Guides Lambda (Node.js + Docker) - Solutions Delivery
# =============================================================================
# FLUJO:
#   1. Lint    -> node --check (validacion de sintaxis JS)
#   2. Build   -> Docker build + push a ECR
#   3. Deploy  -> terraform apply (actualiza Lambda con nueva imagen)
#
# A diferencia de auth/backend (Go + ZIP + S3), guides usa:
#   - Node.js 18 con Puppeteer + Chromium para generar PDFs
#   - Docker container image (no ZIP)
#   - ECR como registro de imagenes (no S3)
#
# Terraform lee image_uri desde ECR -> cuando CI/CD pushea una nueva
# imagen :latest, terraform detecta el cambio de digest y actualiza Lambda
#
# SECRETS POR ENVIRONMENT (configurar en GitHub > Settings > Environments):
#   - AWS_ACCESS_KEY_ID
#   - AWS_SECRET_ACCESS_KEY
#   - AWS_REGION
# =============================================================================

name: Guides Lambda CI/CD

on:
    push:
        branches:
            - main
            - develop
        paths:
            - "guides/**"
            - ".github/workflows/guides.yml"

    pull_request:
        branches:
            - main
        paths:
            - "guides/**"

    workflow_dispatch:
        inputs:
            environment:
                description: "Entorno de deploy"
                required: true
                default: "dev"
                type: choice
                options:
                    - dev
                    - prod

concurrency:
    group: guides-${{ github.ref }}
    cancel-in-progress: true

env:
    NODE_VERSION: "18"
    WORKING_DIRECTORY: "guides"
    NAME_PREFIX: "solutions"

jobs:
    # =========================================================================
    # JOB 1: LINT
    # =========================================================================
    # Valida sintaxis de los archivos JS
    # No hay ESLint configurado, asi que usamos node --check
    # Si agregas ESLint en el futuro, reemplaza esto con npm run lint
    # =========================================================================
    lint:
        name: Lint
        runs-on: ubuntu-latest
        defaults:
            run:
                working-directory: ${{ env.WORKING_DIRECTORY }}

        steps:
            - name: Checkout codigo
              uses: actions/checkout@v4

            - name: Setup Node.js ${{ env.NODE_VERSION }}
              uses: actions/setup-node@v4
              with:
                  node-version: ${{ env.NODE_VERSION }}

            - name: Verificar sintaxis JS
              run: |
                  echo "Validando sintaxis de archivos JavaScript..."
                  errors=0
                  for file in *.js; do
                    if ! node --check "$file" 2>/dev/null; then
                      echo "::error file=$file::Error de sintaxis en $file"
                      errors=$((errors + 1))
                    fi
                  done
                  if [ "$errors" -gt 0 ]; then
                    echo "::error::Se encontraron $errors archivo(s) con errores de sintaxis"
                    exit 1
                  fi
                  echo "Todos los archivos JS son validos"

            - name: Verificar package-lock.json actualizado
              run: |
                  npm ci
                  if [ -n "$(git diff -- package-lock.json)" ]; then
                    echo "::error::package-lock.json no esta actualizado. Ejecuta 'npm install' localmente."
                    exit 1
                  fi

    # =========================================================================
    # JOB 2: BUILD + PUSH A ECR
    # =========================================================================
    # Construye la imagen Docker y la sube a ECR
    # En PRs solo valida que el Docker build funciona, NO pushea
    # =========================================================================
    build:
        name: Build & Push
        runs-on: ubuntu-latest
        needs: lint
        defaults:
            run:
                working-directory: ${{ env.WORKING_DIRECTORY }}

        steps:
            - name: Checkout codigo
              uses: actions/checkout@v4

            - name: Determinar environment
              id: env
              run: |
                  if [ "${{ github.ref }}" = "refs/heads/main" ]; then
                    echo "name=prod" >> $GITHUB_OUTPUT
                  elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                    echo "name=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
                  else
                    echo "name=dev" >> $GITHUB_OUTPUT
                  fi

            - name: Configurar AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ secrets.AWS_REGION }}

            - name: Login en Amazon ECR
              id: ecr-login
              uses: aws-actions/amazon-ecr-login@v2

            - name: Obtener ECR repository URL
              id: ecr
              env:
                  ENVIRONMENT: ${{ steps.env.outputs.name }}
              run: |
                  ECR_REPO="${{ env.NAME_PREFIX }}-lambda-repo-create_guides-${ENVIRONMENT}"
                  REGISTRY="${{ steps.ecr-login.outputs.registry }}"
                  echo "repo=${ECR_REPO}" >> $GITHUB_OUTPUT
                  echo "image=${REGISTRY}/${ECR_REPO}:latest" >> $GITHUB_OUTPUT
                  echo "ECR Repository: ${ECR_REPO}"
                  echo "Full image: ${REGISTRY}/${ECR_REPO}:latest"

            - name: Build imagen Docker
              run: |
                  docker build \
                    --platform linux/amd64 \
                    -t ${{ steps.ecr.outputs.repo }}:latest \
                    -f Dockerfile \
                    .
                  echo "Image size: $(docker image inspect ${{ steps.ecr.outputs.repo }}:latest --format='{{.Size}}' | numfmt --to=iec 2>/dev/null || echo 'N/A')"

            # Solo pushear en push o workflow_dispatch (NO en PRs)
            - name: Tag imagen para ECR
              if: github.event_name != 'pull_request'
              run: |
                  docker tag \
                    ${{ steps.ecr.outputs.repo }}:latest \
                    ${{ steps.ecr.outputs.image }}

            - name: Push imagen a ECR
              if: github.event_name != 'pull_request'
              run: |
                  docker push ${{ steps.ecr.outputs.image }}
                  echo "Pushed: ${{ steps.ecr.outputs.image }}"

    # =========================================================================
    # JOB 3: DEPLOY DEV
    # =========================================================================
    # Terraform detecta que la imagen :latest en ECR tiene un nuevo digest
    # y actualiza la Lambda para usar la nueva imagen
    # =========================================================================
    deploy-dev:
        name: Deploy to DEV
        runs-on: ubuntu-latest
        needs: build
        if: |
            (github.ref == 'refs/heads/develop' && github.event_name == 'push') ||
            (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
        environment: dev

        steps:
            - name: Checkout codigo
              uses: actions/checkout@v4

            - name: Setup Terraform
              uses: hashicorp/setup-terraform@v3
              with:
                  terraform_version: "1.12.1"

            - name: Configurar AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ secrets.AWS_REGION }}

            - name: Terraform Init
              working-directory: infra/envs/dev
              run: terraform init

            - name: Terraform Apply (solo guides)
              working-directory: infra/envs/dev
              run: |
                  terraform apply \
                    -var-file="dev.tfvars" \
                    -target=module.guides \
                    -auto-approve

            - name: Verificar deploy
              run: |
                  FUNCTION_NAME="${{ env.NAME_PREFIX }}-lambda-create-guides-dev"
                  aws lambda wait function-active-v2 --function-name "$FUNCTION_NAME"
                  echo "Lambda $FUNCTION_NAME is active and ready!"

    # =========================================================================
    # JOB 4: DEPLOY PRODUCTION
    # =========================================================================
    deploy-prod:
        name: Deploy to PRODUCTION
        runs-on: ubuntu-latest
        needs: build
        if: |
            (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
            (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod')
        environment: production

        steps:
            - name: Checkout codigo
              uses: actions/checkout@v4

            - name: Setup Terraform
              uses: hashicorp/setup-terraform@v3
              with:
                  terraform_version: "1.12.1"

            - name: Configurar AWS credentials
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ secrets.AWS_REGION }}

            - name: Terraform Init
              working-directory: infra/envs/prod
              run: terraform init

            - name: Terraform Apply (solo guides)
              working-directory: infra/envs/prod
              run: |
                  terraform apply \
                    -var-file="prod.tfvars" \
                    -target=module.guides \
                    -auto-approve

            - name: Verificar deploy
              run: |
                  FUNCTION_NAME="${{ env.NAME_PREFIX }}-lambda-create-guides-prod"
                  aws lambda wait function-active-v2 --function-name "$FUNCTION_NAME"
                  echo "Lambda $FUNCTION_NAME is active and ready!"
